#### はじめに

名前：杉本 雅広（すぎもと まさひろ）

運営中： wgld.org, WebGL総本山

![doxas](doxas.png)

---

#### はじめに

まずは、jsstg へ作品を出展してくださった方、そして連動企画となる本勉強会にご参加くださった方、ありがとうございます。
jsstg 2015 は第二回にあたりますが、今後また第三回も開催できればいいなと思っています。
今後とも jsstg をよろしくお願いします。

---

#### 本日のテーマ

**マルチプラットフォーム WebGL**

jsstg 2015 に出展した「torna-do」の実装を紐解きつつ、モバイル端末でも動作可能な WebGL コンテンツの作成について考えていきます。
モバイル端末ならではのセンサーを使った実装や、いかに描画の負荷を抑えつつリッチな表現を行うかなど、お話できればと思っています。

---

#### torna-do

jsstg 2015 に出展した、果たしてこれはシューティングゲームと呼べるのかという一作。

![torna-do](torna_do.jpg)

---

#### 最初に思い描いていたコンセプト

* モバイル端末でも動作するようにしたい
* モバイル端末ならではのセンサー利用したい
* 負荷を少しでも抑えるため頂点数は少なくしたい
* でも見た目はちょっとくらいかっこよくしたい

---

#### モバイルならではのセンサー

PC には無い、モバイル端末ならではのセンサーを使った実装をしたかった。
真っ先に思いついたのが、「タッチ」と「ジャイロ」のふたつ。
タッチを使うなら*マルチタッチ*にしたかったが、なんとなくジャイロのほうが面白そうだったのでジャイロセンサーを用いた移動形式に。

---

#### ジャイロセンサーとは

ジャイロセンサーは、モバイル端末の「傾き」を計測するセンサーです。
javascript から参照できるセンサーとしては、最も初期から対応が進められてきたものなので、Android や iOS で比較的データを取りやすいセンサーだと思います。
ちなみに、どのセンサーの情報が取れるのかは OS ではなくブラウザの実装によります。

---

#### ジャイロセンサーの値をどう使うか

ジャイロセンサーの値は、端末の傾きを X Y Z の三軸で取った結果として取得できます。
正式な表記が X Y Z ではなく alpha、beta、gamma なのでちょっと紛らわしいです。
--X = beta, Y = gamma, Z = alpha--

---

#### ジャイロセンサーの値をどう使うか

![device orientation](orientation.jpg)

---

#### ゲームにどう組み込んだか

torna-do の場合は、alpha の情報は利用せずに、beta と gamma の情報だけを自機キャラクターの移動に利用してます。動作環境が PC の場合は、キー入力により一定の慣性が付くようにした。
キー入力で慣性が付くようにしたのには理由があり、モバイル端末での実行時に比べ*キー入力のほうが圧倒的に操作しやすい*ことが予想できたので、PC 側では少し難易度を上げたかったため。

---

#### モバイル端末での移動処理

モバイル端末の場合は、傾きに応じてキャラクターに適用される「慣性ベクトルを増減させる」方針とした。
素直にセンサーの値をそのまま移動に適用してしまうと、移動が速くなりすぎたり、ブレが大きく制御しにくいと感じる傾向があったためにこのような方針にしました。
PC の場合も、この慣性ベクトルをキー入力に応じて一定数増減させるようにしてます。

---

#### 慣性ベクトルの減衰

慣性ベクトルに対しては、ループのたびに`0.95`を乗算する仕組みになっていて、これによって自然な減衰のような効果が得られるようになります。
非常に簡単な乗算処理を毎ループ行うだけで、まるで水中を漂っているかのようなふわふわとした動きが実現できます。
計算の負荷も高くありませんし、手軽に使えるのでおすすめです。

---

#### イベントの発火回数問題

ジャイロセンサーを用いる場合、`deviceorientation`という名前のイベントに`addEventListener`で関数を登録します。
実際にやってみるとわかりますが、ジャイロセンサーは非常に精度が高いです。
ほとんど振動の無い部屋で、テーブルの上に置いて放置するくらいのことをしないと、常にイベントが発火し続けます（機種によるのかもしれませんが）。

---

#### イベントの発火回数問題

このことから、描画に関連するイベントを`addEventListener`と紐付けたり、コストの高い計算をイベント発火のたびに行ったりすると、非常に大きな負荷になる可能性があります。
やり方はいろいろ考えられますが、適当にイベントを間引くような仕組みを入れたり、イベント発火によって実行される処理の内容をよく吟味する必要があると思います。

---

#### イベントの発火回数問題

たとえば、イベント発火のたびに「数値を加算」するような処理を仕込んでいると、ループよりも高い頻度でイベントが発火してしまった際に、想定していたよりも加算処理が多く発生してしまう可能性がありますよね。
ループの動きと連動したフラグを使って、イベント発火時の処理を場合により`return`するなど、なにかしらの工夫が必要な場面も考えられますので、注意です。

---

#### 

---

#### 

---

#### 

---

#### 









---

### agenda

実装概念

* スクリーンサイズが割と難点（縦横比）
* イベントの発火回数を考慮した実装
* マルチプラットフォームという懸念とPCとの共存
* UIが狭いのでそれに対する工夫


javascript寄りの話

* 冪乗計算による減衰処理
* イベントの発火回数
* 敵の移動ロジック

WebGLな話

* プロシージャルにできるものはそうする
* オフスクリーンレンダリングを活用した方法
* ガウシアンブラー
* 加算合成


問題点

* 音声ファイル重いね！
* 



